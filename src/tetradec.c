/* Generated by XDS Modula-2 to ANSI C v4.20 translator */

#define X2C_int32
#define X2C_index32
#ifndef X2C_H_
#include "X2C.h"
#endif
#define tetradec_C_
#ifndef osi_H_
#include "osi.h"
#endif
#include <osic.h>
#ifndef mlib_H_
#include "mlib.h"
#endif
#ifndef udp_H_
#include "udp.h"
#endif
#ifndef aprspos_H_
#include "aprspos.h"
#endif
#ifndef aprsstr_H_
#include "aprsstr.h"
#endif
#ifndef viterbi_cch_H_
#include "viterbi_cch.h"
#endif
#ifndef csdecoder_H_
#include "csdecoder.h"
#endif

/* decode demodulated and frame synced tetra d4psk */
#define tetradec_PI 3.1415926535898

#define tetradec_PI2 6.2831853071796

#define tetradec_RAD 1.7453292519943E-2

#define tetradec_D4BITS 2
/* bits per symbol */

#define tetradec_SBBLK1BITS 120

#define tetradec_SBBLK2BITS 216

#define tetradec_SBBBKBITS 30

#define tetradec_NDBBBK1BITS 14

#define tetradec_NDBBBK1OFFSET 230

#define tetradec_NDBBBK2OFFSET 266

#define tetradec_NDBBBK2BITS 16

#define tetradec_NDBBLKBITS 216

#define tetradec_NDBBLK1OFFSET 14

#define tetradec_NDBBLK2OFFSET 282

#define tetradec_UNDBBLK1OFFSET 28

#define tetradec_UNDBBLK2OFFSET 266

struct CONTEXT;


struct CONTEXT {
   uint32_t xor;
   uint32_t mn;
   uint32_t tn;
   uint32_t fn;
   uint32_t mccmnc;
   uint32_t bcc;
   uint32_t la;
   uint32_t lac;
   uint32_t ccc;
   int32_t offset;
   float dmhz;
   float db;
   char istrafic;
};


struct PROCESSHANDLE {
   int32_t pid;
   char started;
   char runs;
   int32_t ptyfd;
   int32_t exitcode;
};

struct MCC;

typedef struct MCC * pMCC;


struct MCC {
   pMCC next;
   uint32_t mccmnc;
   char text[41];
};

static uint32_t tetradec_SCRAMBINIT = 0x3UL;

#define tetradec_INB 16384

#define tetradec_CHANS 4

#define tetradec_DLEN 432

#define tetradec_ALEN 480

#define tetradec_MINFOUND 1

#define tetradec_RXDEL 40

#define tetradec_RXDELLONG 200

#define tetradec_SCANTOL 10000

static char scanonce;

static char scanfound;

static char isuplink;

static char rxany;

static char verb2;

static char verb;

static uint32_t jipnum;

static int32_t scanstart;

static int32_t scanend;

static int32_t scanoffs;

static int32_t soundfd;

static int32_t udpsock;

static int32_t chanfds[4];

static uint32_t scanstate;

static uint32_t ipnum;

static uint32_t rxdelay;

static uint32_t scansteps;

static uint32_t channels;

static uint32_t RMTAB[16384];

static uint32_t judpport;

static uint32_t fromport;

struct _0;


struct _0 {
   short af[480];
   float alc;
   char filled;
};

static struct _0 audiobufs[4];

static pMCC cachpm;

static pMCC mcc;

static uint32_t cachmn;

static char gpsfilename[1001];

static char mccfilename[1001];

static struct CONTEXT context;


static void Err(const char text[], uint32_t text_len)
{
   osi_WrStr("tetradec: ", 11ul);
   osi_WrStr(text, text_len);
   osi_WrStrLn(" error abort", 13ul);
   X2C_ABORT();
} /* end Err() */

/*
PROCEDURE monotonicms():CARDINAL;
VAR s,ns:CARDINAL;
BEGIN
  timens(TRUE, s, ns);
  RETURN ns DIV 1000000 + s*1000
END monotonicms;
*/
#define tetradec_bytes 2


/*-------- write wav header */
static void wwav(int32_t fd, uint32_t hz, uint32_t chan)
{
   char b[44];
   strncpy(b,"RIFF    WAVEfmt ",44u);
   b[4U] = '\377'; /* len */
   b[5U] = '\377';
   b[6U] = '\377';
   b[7U] = '\377';
   b[16U] = '\020';
   b[17U] = 0;
   b[18U] = 0;
   b[19U] = 0;
   b[20U] = '\001'; /* PCM/ALAW */
   b[21U] = 0;
   b[22U] = (char)chan; /* channels */
   b[23U] = 0;
   b[24U] = (char)(hz&255UL); /* samp */
   b[25U] = (char)(hz/256UL&255UL);
   b[26U] = (char)(hz/65536UL&255UL);
   b[27U] = (char)(hz/16777216UL);
   b[28U] = (char)(hz*2UL&255UL); /* byte/s */
   b[29U] = (char)((hz*2UL)/256UL&255UL);
   b[30U] = (char)((hz*2UL)/65536UL);
   b[31U] = 0;
   b[32U] = '\002'; /* block byte */
   b[33U] = 0;
   b[34U] = '\020'; /* bit/samp */
   b[35U] = 0;
   b[36U] = 'd';
   b[37U] = 'a';
   b[38U] = 't';
   b[39U] = 'a';
   b[40U] = '\377'; /* len */
   b[41U] = '\377';
   b[42U] = '\377';
   b[43U] = '\377';
   if (fd>=0L) osi_WrBin(fd, (char *)b, 44u/1u, 44UL);
} /* end wwav() */


static void readmccmnc(void)
{
   int32_t fp;
   char c;
   uint32_t mn;
   uint32_t num0;
   uint32_t n;
   char s[1001];
   pMCC m;
   if (mccfilename[0U]==0) return;
   fp = osi_OpenRead(mccfilename, 1001ul);
   if (fp>=0L) {
      n = 0UL;
      num0 = 0UL;
      while (osi_RdBin(fp, (char *) &c, 1u/1u, 1UL)==1L) {
         if (num0<=1UL) {
            if ((uint8_t)c>='0' && (uint8_t)c<='9') {
               n = (n*10UL+(uint32_t)(uint8_t)c)-48UL;
            }
            else {
               ++num0;
               mn = mn*65536UL+n;
               n = 0UL;
            }
         }
         else if ((uint8_t)c>=' ') {
            if (n<1000UL) {
               s[n] = c;
               ++n;
            }
         }
         else {
            if (mn) {
               if (n<=1000UL) s[n] = 0;
               osic_alloc((char * *) &m, sizeof(struct MCC));
               if (m==0) return;
               memset((char *)m,(char)0,sizeof(struct MCC));
               m->mccmnc = mn;
               aprsstr_Assign(m->text, 41ul, s, 1001ul);
               m->next = mcc;
               mcc = m;
            }
            num0 = 0UL;
            n = 0UL;
         }
      }
      osic_Close(fp);
   }
   else osi_WerrLn("mmc-file not readable", 22ul);
   if (verb2) {
      m = mcc;
      while (m) {
         osic_WrINT32(m->mccmnc/65536UL, 6UL);
         osic_WrINT32(m->mccmnc&65535UL, 6UL);
         osi_WrStr(" ", 2ul);
         osi_WrStrLn(m->text, 41ul);
         m = m->next;
      }
   }
} /* end readmccmnc() */


static void printmcc(uint32_t mn)
{
   if (cachmn!=mn) {
      cachpm = mcc;
      while (cachpm && cachpm->mccmnc!=mn) cachpm = cachpm->next;
   }
   cachmn = mn;
   if (cachpm) {
      osi_WrStr(" [", 3ul);
      osi_WrStr(cachpm->text, 41ul);
      osi_WrStr("]", 2ul);
   }
} /* end printmcc() */

/*------- init reed muller decode */
static uint8_t tetradec_RM3014[224] = {1U,0U,0U,1U,1U,0U,1U,1U,0U,1U,1U,0U,
                0U,0U,0U,0U,0U,0U,1U,0U,1U,1U,0U,1U,1U,1U,1U,0U,0U,0U,0U,0U,
                1U,1U,1U,1U,1U,1U,0U,0U,0U,0U,1U,0U,0U,0U,0U,0U,1U,1U,1U,0U,
                0U,0U,0U,0U,0U,0U,1U,1U,1U,1U,0U,0U,1U,0U,0U,1U,1U,0U,0U,0U,
                0U,0U,1U,1U,1U,0U,1U,0U,0U,1U,0U,1U,0U,1U,0U,0U,0U,0U,1U,1U,
                0U,1U,1U,0U,0U,0U,1U,0U,1U,1U,0U,0U,0U,0U,1U,0U,1U,1U,1U,0U,
                1U,1U,1U,1U,1U,1U,1U,1U,1U,1U,0U,1U,1U,1U,1U,1U,1U,0U,0U,0U,
                0U,0U,1U,1U,0U,0U,1U,1U,1U,0U,0U,1U,0U,1U,0U,0U,0U,0U,1U,0U,
                1U,0U,1U,1U,0U,1U,0U,1U,0U,0U,1U,0U,0U,0U,0U,1U,1U,0U,1U,0U,
                1U,1U,0U,1U,0U,0U,0U,1U,0U,0U,1U,0U,0U,1U,1U,1U,0U,0U,1U,1U,
                0U,0U,0U,0U,1U,0U,0U,1U,0U,1U,1U,0U,1U,0U,1U,1U,0U,0U,0U,0U,
                0U,1U,0U,0U,1U,1U,1U,0U,0U,1U,1U,1U};

static uint8_t _cnst[224] = {1U,0U,0U,1U,1U,0U,1U,1U,0U,1U,1U,0U,0U,0U,0U,
                0U,0U,0U,1U,0U,1U,1U,0U,1U,1U,1U,1U,0U,0U,0U,0U,0U,1U,1U,1U,
                1U,1U,1U,0U,0U,0U,0U,1U,0U,0U,0U,0U,0U,1U,1U,1U,0U,0U,0U,0U,
                0U,0U,0U,1U,1U,1U,1U,0U,0U,1U,0U,0U,1U,1U,0U,0U,0U,0U,0U,1U,
                1U,1U,0U,1U,0U,0U,1U,0U,1U,0U,1U,0U,0U,0U,0U,1U,1U,0U,1U,1U,
                0U,0U,0U,1U,0U,1U,1U,0U,0U,0U,0U,1U,0U,1U,1U,1U,0U,1U,1U,1U,
                1U,1U,1U,1U,1U,1U,1U,0U,1U,1U,1U,1U,1U,1U,0U,0U,0U,0U,0U,1U,
                1U,0U,0U,1U,1U,1U,0U,0U,1U,0U,1U,0U,0U,0U,0U,1U,0U,1U,0U,1U,
                1U,0U,1U,0U,1U,0U,0U,1U,0U,0U,0U,0U,1U,1U,0U,1U,0U,1U,1U,0U,
                1U,0U,0U,0U,1U,0U,0U,1U,0U,0U,1U,1U,1U,0U,0U,1U,1U,0U,0U,0U,
                0U,1U,0U,0U,1U,0U,1U,1U,0U,1U,0U,1U,1U,0U,0U,0U,0U,0U,1U,0U,
                0U,1U,1U,1U,0U,0U,1U,1U,1U};

static void RMinit(void)
{
   uint32_t j;
   uint32_t i0;
   uint32_t b;
   uint32_t rows[14];
   for (i0 = 0UL; i0<=13UL; i0++) {
      b = X2C_LSH(0x1UL,32,(int32_t)i0);
      for (j = 0UL; j<=15UL; j++) {
         if ((uint32_t)_cnst[j+16UL*i0]>0UL) b |= (1UL<<14UL+j);
      } /* end for */
      rows[i0] = b;
   } /* end for */
   for (j = 0UL; j<=16383UL; j++) {
      b = 0UL;
      for (i0 = 0UL; i0<=13UL; i0++) {
         if (X2C_IN(13UL-i0,32,(uint32_t)j)) b = b^rows[i0];
      } /* end for */
      RMTAB[j] = b;
   } /* end for */
} /* end RMinit() */


static int32_t createnonblockfile(char fn[], uint32_t fn_len)
{
   int32_t fd;
   int32_t createnonblockfile_ret;
   X2C_PCOPY((void **)&fn,fn_len);
   fd = osi_OpenNONBLOCK(fn, fn_len);
   if (fd<0L || !osi_IsFifo(fd)) {
      /* no pipe */
      if (fd>=0L) osic_Close(fd);
      fd = osi_OpenWrite(fn, fn_len);
   }
   createnonblockfile_ret = fd;
   X2C_PFREE(fn);
   return createnonblockfile_ret;
} /* end createnonblockfile() */


static uint32_t getscramb(uint32_t mcc0, uint32_t mnc,
                uint32_t colour)
/*p.723*/
{
   return 0x3UL|X2C_LSH((uint32_t)colour&0x3FUL|X2C_LSH((uint32_t)
                mnc&0x3FFFUL,32,6)|X2C_LSH((uint32_t)mcc0&0x3FFUL,32,20),
                32,2);
} /* end getscramb() */

#define tetradec_DEFAULTIP 0x7F000001 

#define tetradec_PORTSEP ":"


static int32_t GetIp(char h[], uint32_t h_len, uint32_t * ip,
                uint32_t * port)
{
   uint32_t p;
   uint32_t n;
   uint32_t i0;
   char ok0;
   int32_t GetIp_ret;
   X2C_PCOPY((void **)&h,h_len);
   p = 0UL;
   h[h_len-1] = 0;
   *ip = 0UL;
   for (i0 = 0UL; i0<=4UL; i0++) {
      if (i0>=3UL || h[0UL]!=':') {
         n = 0UL;
         ok0 = 0;
         while ((uint8_t)h[p]>='0' && (uint8_t)h[p]<='9') {
            ok0 = 1;
            n = (n*10UL+(uint32_t)(uint8_t)h[p])-48UL;
            ++p;
         }
         if (!ok0) {
            GetIp_ret = -1L;
            goto label;
         }
      }
      if (i0<3UL) {
         if (h[0UL]!=':') {
            if (h[p]!='.' || n>255UL) {
               GetIp_ret = -1L;
               goto label;
            }
            *ip =  *ip*256UL+n;
         }
      }
      else if (i0==3UL) {
         if (h[0UL]!=':') {
            *ip =  *ip*256UL+n;
            if (h[p]!=':' || n>255UL) {
               GetIp_ret = -1L;
               goto label;
            }
         }
         else {
            p = 0UL;
            *ip = 2130706433UL;
         }
      }
      else if (n>65535UL) {
         GetIp_ret = -1L;
         goto label;
      }
      *port = n;
      ++p;
   } /* end for */
   GetIp_ret = 0L;
   label:;
   X2C_PFREE(h);
   return GetIp_ret;
} /* end GetIp() */


static int32_t num(const char h[], uint32_t h_len, uint32_t * i0)
{
   uint32_t n;
   char sg;
   if (h[*i0]!=',') {
      sg = 0;
      n = 0UL;
      if (h[*i0]=='+') ++*i0;
      else if (h[*i0]=='-') {
         sg = 1;
         ++*i0;
      }
      while (((*i0<h_len-1 && h[*i0]!=',') && (uint8_t)h[*i0]>='0')
                && (uint8_t)h[*i0]<='9') {
         n = (n*10UL+(uint32_t)(uint8_t)h[*i0])-48UL;
         ++*i0;
      }
      if (sg) return -(int32_t)n;
      return (int32_t)n;
   }
   return 0L;
} /* end num() */


static void parms(void)
{
   char h[4096];
   char lasth;
   char err;
   uint32_t ch;
   uint32_t bcc;
   uint32_t mcc0;
   uint32_t mnc;
   uint32_t i0;
   err = 0;
   udpsock = -1L;
   soundfd = -2L;
   channels = 2UL;
   scansteps = 25000UL;
   for (ch = 0UL; ch<=3UL; ch++) {
      chanfds[ch] = -1L;
   } /* end for */
   ch = 0UL;
   for (;;) {
      osi_NextArg(h, 4096ul);
      if (h[0U]==0) break;
      if ((h[0U]=='-' && h[1U]) && h[2U]==0) {
         lasth = h[1U];
         if (lasth=='h') {
            osi_WrStrLn("Tetra dqpsk decoder with 1 2 or 4 channel .wav voice\
 output (unencrypted trunking mode)", 88ul);
            osi_WrStrLn(" -c             audio channels 1, 2 or 4, less than \
4: mono/stereo downmix (2)", 79ul);
            osi_WrStrLn(" -h             this", 21ul);
            osi_WrStrLn(" -J <x.x.x.x:udpport>  receive udp json tetra frames\
 with metadata, ip=0.0.0.0 reveive from any source", 103ul);
            osi_WrStrLn(" -m <mcc-filename>  read file with \'mcc mnc text\' \
lines", 56ul);
            osi_WrStrLn(" -S same as -s but stop scan if signal found",
                45ul);
            osi_WrStrLn(" -s <scanstart(Hz)>,<scanend(Hz)>[,<scanstep(Hz)>]  \
scan in iq band, send \"tune\" in json udp to fsk4rx (25000)", 111ul);
            osi_WrStrLn("                  write csv mcc,mnc,bcc,ssi,tx-freq,\
dB", 55ul);
            osi_WrStrLn(" -T same as -s but terminate after one scan", 44ul);
            osi_WrStrLn(" -v             verbous", 24ul);
            osi_WrStrLn(" -u <mcc,mnc,colourcode> decoding uplink needs scram\
bler code seen by decoding downlink -v \"CC\" or give any number and decode a\
 while downlink before uplink", 157ul);
            osi_WrStrLn(" -W <file/pipename> write wav file or unbreakable pi\
pe with slot 0, repeat -W for slot 1 2 3", 93ul);
            osi_WrStrLn(" -w <file/pipename> write wav file or unbreakable pi\
pe with -c channels downmixed and gain limited", 99ul);
            osi_WrStrLn("", 1ul);
            osi_WrStrLn("mknod pipe.wav p", 17ul);
            osi_WrStrLn("rtl_sdr -f 430.5m -s 1000000 - | fsk4rx -i /dev/stdi\
n -m d,18000,20000 -r 1000000 -t 37500 -J 127.0.0.1:7000", 109ul);
            osi_WrStrLn("tetradec -J 0.0.0.0:7000 -w pipe.wav -v", 40ul);
            osi_WrStrLn("aplay pipe.wav", 15ul);
            X2C_ABORT();
         }
         if (lasth=='v') verb = 1;
         else if (lasth=='V') {
            verb = 1;
            verb2 = 1;
         }
         else if (lasth=='u') {
            osi_NextArg(h, 4096ul);
            i0 = 0UL;
            mcc0 = (uint32_t)num(h, 4096ul, &i0);
            if (h[i0]!=',') Err("-u mcc,mnc,bcc", 15ul);
            ++i0;
            mnc = (uint32_t)num(h, 4096ul, &i0);
            if (h[i0]!=',') Err("-u mcc,mnc,bcc", 15ul);
            ++i0;
            bcc = (uint32_t)num(h, 4096ul, &i0);
            if (h[i0]) Err("-u mcc,mnc,bcc", 15ul);
            context.xor = getscramb(mcc0, mnc, bcc);
            isuplink = 1;
         }
         else if (lasth=='J') {
            osi_NextArg(h, 4096ul);
            if (GetIp(h, 4096ul, &jipnum, &judpport)<0L) {
               Err("-J ip:port number", 18ul);
            }
            if (udpsock<0L) {
               udpsock = openudp();
            }
            if (udpsock<0L) Err("-J cannot open udp socket", 26ul);
            if (bindudp(udpsock, judpport)<0L) {
               Err("-J cannot bind input udp port", 30ul);
            }
         }
         else if (lasth=='c') {
            osi_NextArg(h, 4096ul);
            if (!aprsstr_StrToCard(h, 4096ul,
                &channels) || (channels!=1UL && channels!=2UL)
                && channels!=4UL) Err("-c <audiochannels> 1,2,4", 25ul);
         }
         else if ((lasth=='s' || lasth=='S') || lasth=='T') {
            scanonce = lasth=='T';
            scanfound = lasth=='S';
            osi_NextArg(h, 4096ul);
            i0 = 0UL;
            scanstart = num(h, 4096ul, &i0);
            if (h[i0]==',') {
               ++i0;
               scanend = num(h, 4096ul, &i0);
            }
            if (h[i0]==',') {
               ++i0;
               scansteps = (uint32_t)num(h, 4096ul, &i0);
            }
            if (h[i0]) {
               Err("-s -S or -T <scanstart(Hz)>,<scanend(Hz)>[,<scanstep(Hz)>\
]", 59ul);
            }
            if (scanend<=scanstart) Err("-s -S -T start>=end?", 21ul);
            scanstate = 1UL;
         }
         else if (lasth=='m') {
            osi_NextArg(mccfilename, 1001ul);
            if (mccfilename[0U]==0) Err("-m <mcc-filename", 17ul);
         }
         else if (lasth=='g') {
            osi_NextArg(gpsfilename, 1001ul);
            if (gpsfilename[0U]==0) Err("-m <gps-filename", 17ul);
         }
         else if (lasth=='w') {
            osi_NextArg(h, 4096ul);
            soundfd = createnonblockfile(h, 4096ul);
         }
         else if (lasth=='W') {
            /*        soundfd:=OpenWrite(h); */
            osi_NextArg(h, 4096ul);
            if (ch<4UL) {
               chanfds[ch] = createnonblockfile(h, 4096ul);
               if (chanfds[ch]>=0L) wwav(chanfds[ch], 8000UL, 1UL);
               else Err("-W <soundfilename> cannot open sound output", 44ul);
               ++ch;
            }
            else Err("-W  maximum 4 sound channels", 29ul);
         }
         else err = 1;
      }
      else err = 1;
      if (err) break;
   }
   if (soundfd>=0L) wwav(soundfd, 8000UL, channels);
   else if (soundfd>=-1L) {
      Err("-w <soundfilename> cannot open sound output", 44ul);
   }
   if (err) {
      osi_WrStr(">", 2ul);
      osi_WrStr(h, 4096ul);
      osi_WrStrLn("< use -h", 9ul);
      X2C_ABORT();
   }
} /* end parms() */

#define tetradec_MAXG 20.0


static short lim(short u, float * mul, float lim0)
{
   float ll;
   float r;
   r = (float)u*(20.0f-*mul);
   ll = (float)fabs(r)-lim0;
   if (ll>0.0f) *mul = *mul+(20.0f-*mul)*ll*0.00001f;
   else *mul =  *mul*0.9999f;
   if (r>lim0) r = lim0;
   else if (r<-lim0) r = -lim0;
   return (short)X2C_TRUNCI(r,-32768,32767);
} /* end lim() */


static void decodeaudio(const signed char frame[], uint32_t frame_len,
                uint32_t ch)
{
   uint32_t sp;
   uint32_t c;
   uint32_t i0;
   short fw[432];
   short sb[1920];
   if (ch>=4UL) ch = 3UL;
   if (audiobufs[ch].filled) {
      /* buffer filled and new data for this channel so dump sound */
      sp = 0UL;
      memset((char *)sb,(char)0,3840UL);
      if (channels==1UL) {
         /* mix down to mono */
         for (i0 = 0UL; i0<=479UL; i0++) {
            for (c = 0UL; c<=3UL; c++) {
               sb[sp] += lim(audiobufs[c].af[i0], &audiobufs[c].alc,
                8000.0f);
            } /* end for */
            ++sp;
         } /* end for */
      }
      else if (channels==2UL) {
         /* mix down to stereo */
         for (i0 = 0UL; i0<=479UL; i0++) {
            sb[sp] += lim(audiobufs[0U].af[i0], &audiobufs[0U].alc,
                16000.0f);
            sb[sp] += lim(audiobufs[2U].af[i0], &audiobufs[2U].alc,
                10600.0f);
            sb[sp] += lim(audiobufs[3U].af[i0], &audiobufs[3U].alc, 5300.0f);
            ++sp;
            sb[sp] += lim(audiobufs[2U].af[i0], &audiobufs[2U].alc, 5300.0f);
            sb[sp] += lim(audiobufs[3U].af[i0], &audiobufs[3U].alc,
                10600.0f);
            sb[sp] += lim(audiobufs[1U].af[i0], &audiobufs[1U].alc,
                16000.0f);
            ++sp;
         } /* end for */
      }
      else {
         for (i0 = 0UL; i0<=479UL; i0++) {
            /* 4 channel audio */
            for (c = 0UL; c<=3UL; c++) {
               sb[sp] = lim(audiobufs[c].af[i0], &audiobufs[c].alc,
                32000.0f);
               ++sp;
            } /* end for */
         } /* end for */
      }
      osi_WrBin(soundfd, (char *)sb, 3840u/1u, sp*2UL);
      osic_flush();
      for (c = 0UL; c<=3UL; c++) {
         memset((char *)audiobufs[c].af,(char)0,960UL);
         audiobufs[c].filled = 0;
      } /* end for */
   }
   for (i0 = 0UL; i0<=431UL; i0++) {
      fw[i0] = (short)frame[i0]; /* make 16 bit (but no soft viterbi) */
   } /* end for */
   csdec(audiobufs[ch].af, fw); /* decode audio */
   audiobufs[ch].filled = 1;
   if (chanfds[ch]>=0L) {
      osi_WrBin(chanfds[ch], (char *)audiobufs[ch].af, 960u/1u, 960UL);
                /* write single channel audio file */
   }
} /* end decodeaudio() */


static void sendj(int32_t offs)
{
   int32_t ret;
   char h[100];
   char s[100];
   strncpy(s,"{\"tune\":",100u);
   aprsstr_IntToStr(offs, 0UL, h, 100ul);
   aprsstr_Append(s, 100ul, h, 100ul);
   aprsstr_Append(s, 100ul, "}", 2ul);
   /*WrStrLn(s); */
   /*WrStr(" ip[");WrHex(ipnum,8,8); WrStr("] "); */
   /*WrStr(" fp[");WrCard(fromport,10); WrStr("] "); */
   ret = udpsend(udpsock, s, (int32_t)aprsstr_Length(s, 100ul), fromport,
                ipnum);
} /* end sendj() */


static void scanstep(char found)
{
   int32_t l1;
   int32_t l0;
   int32_t gfc;
   char g1[101];
   char g0[101];
   if ((found || !rxany && rxdelay>40UL) || rxdelay>200UL) {
      if (found) {
         osic_WrUINT32(context.mccmnc/65536UL, 1UL);
         osi_WrStr(",", 2ul);
         osic_WrUINT32(context.mccmnc&65535UL, 1UL);
         osi_WrStr(",", 2ul);
         osic_WrUINT32(context.bcc, 1UL);
         osi_WrStr(",", 2ul);
         osic_WrUINT32(context.la, 1UL);
         osi_WrStr(",", 2ul);
         osic_WrFixed(context.dmhz, 4L, 1UL);
         osi_WrStr(",", 2ul);
         osic_WrFixed(context.db, 1L, 1UL);
         /*- append a gps line out of a file */
         if (gpsfilename[0]) {
            gfc = osi_OpenRead(gpsfilename, 1001ul);
            if (gfc>=0L) {
               l0 = osi_RdBin(gfc, (char *)g0, 101u/1u, 101UL);
               osic_Close(gfc);
               gfc = osi_OpenRead(gpsfilename, 1001ul);
               if (gfc>=0L) {
                  l1 = osi_RdBin(gfc, (char *)g1, 101u/1u, 101UL);
                /* read twice to check if line write is in progress */
                  osic_Close(gfc);
                  if (l0>0L && l0==l1) {
                     l1 = 0L;
                     while (l1<l0 && g0[l1]==g1[l1]) ++l1;
                  }
                  if (l0>0L && l0!=l1) {
                     /* different */
                     gfc = osi_OpenRead(gpsfilename, 1001ul);
                     if (gfc>=0L) {
                        l0 = osi_RdBin(gfc, (char *)g0, 101u/1u, 101UL);
                /* read again if different */
                        osic_Close(gfc);
                     }
                  }
                  if (l0<=100L) g0[l0] = 0;
                  if (l0>0L) {
                     osi_WrStr(",", 2ul);
                     osi_WrStr(g0, 101ul);
                  }
               }
            }
         }
         /*- append a gps line out of a file */
         osi_WrStrLn("", 1ul);
         if (scanfound) {
            scanstate = 0UL;
            return;
         }
      }
      context.ccc = 0UL;
      context.lac = 0UL;
      context.mccmnc = 0UL;
      rxany = 0;
      rxdelay = 0UL;
      if (scanstate==1UL) {
         scanstate = 2UL;
         scanoffs = scanstart;
      }
      else scanoffs += (int32_t)scansteps;
      if (scanoffs>scanend) {
         scanoffs = scanstart;
         if (scanonce) X2C_ABORT();
      }
      sendj(scanoffs);
   }
} /* end scanstep() */

static int32_t inlen;

static int32_t rdp;

static char inb[4096];


static char getch(void)
{
   char ch;
   char ok0;
   uint32_t ip;
   uint32_t fp;
   if (rdp>=inlen) {
      do {
         inlen = udpreceive(udpsock, inb, 4096L, &fp, &ip);
         if (inlen<=0L) {
            usleep(10000UL);
            if (scanstate>0UL) {
               ++rxdelay;
               ok0 = (context.ccc>=1UL && context.lac>=1UL)
                && context.mccmnc>0UL;
               scanstep(ok0);
            }
         }
      } while (!((inlen>0L && inlen<=4096L) && (jipnum==0UL || jipnum==ipnum)));
      fromport = fp;
      ipnum = ip;
      rdp = 0L;
   }
   ch = inb[rdp];
   ++rdp;
   return ch;
} /* end getch() */


static char getstr(char s[], uint32_t s_len, char * ch)
{
   uint32_t i0;
   do {
      *ch = getch();
      if ((uint8_t)*ch<' ') return 0;
   } while (*ch!='\"');
   i0 = 0UL;
   for (;;) {
      *ch = getch();
      if ((uint8_t)*ch<' ') return 0;
      if (*ch=='\"') {
         if (i0<s_len-1) s[i0] = 0;
         *ch = getch();
         break;
      }
      if (i0<=s_len-1) {
         s[i0] = *ch;
         ++i0;
      }
   }
   return 1;
} /* end getstr() */


static char skip(char * ch)
{
   *ch = getch();
   if ((uint8_t)*ch<' ') return 0;
   if (*ch=='\"') {
      do {
         *ch = getch();
         if ((uint8_t)*ch<' ') return 0;
      } while (*ch!='\"');
      *ch = getch();
      if ((uint8_t)*ch<' ') return 0;
   }
   else {
      do {
         *ch = getch();
         if ((uint8_t)*ch<' ') return 0;
      } while (!(*ch==',' || *ch=='}'));
   }
   return 1;
} /* end skip() */


static char getfix(float * v, char * ch)
{
   float f;
   char neg;
   *v = 0.0f;
   *ch = getch();
   if ((uint8_t)*ch<' ') return 0;
   while (*ch==' ') *ch = getch();
   f = 0.0f;
   neg = 0;
   if (*ch=='-') {
      neg = 1;
      *ch = getch();
   }
   for (;;) {
      if (*ch=='.') f = 0.1f;
      else if ((uint8_t)*ch>='0' && (uint8_t)*ch<='9') {
         if (f==0.0f) {
            *v =  *v*10.0f+(float)((uint32_t)(uint8_t)*ch-48UL);
         }
         else {
            *v = *v+f*(float)((uint32_t)(uint8_t)*ch-48UL);
            f = f*0.1f;
         }
      }
      else break;
      *ch = getch();
   }
   if (neg) *v = -*v;
   return 1;
} /* end getfix() */


static char getint(int32_t * v, char * ch)
{
   char neg;
   *v = 0L;
   *ch = getch();
   if ((uint8_t)*ch<' ') return 0;
   while (*ch==' ') *ch = getch();
   neg = 0;
   if (*ch=='-') {
      neg = 1;
      *ch = getch();
   }
   for (;;) {
      if ((uint8_t)*ch>='0' && (uint8_t)*ch<='9') {
         *v =  *v*10L+(int32_t)((uint32_t)(uint8_t)*ch-48UL);
      }
      else break;
      *ch = getch();
   }
   if (neg) *v = -*v;
   return 1;
} /* end getint() */


static uint32_t d640(char c)
{
   if (c=='=') return 64UL;
   if (c=='+') return 62UL;
   if (c=='/') return 63UL;
   if ((uint8_t)c>='0' && (uint8_t)c<='9') {
      return ((uint32_t)(uint8_t)c+52UL)-48UL;
   }
   if ((uint8_t)c>='A' && (uint8_t)c<='Z') {
      return (uint32_t)(uint8_t)c-65UL;
   }
   if ((uint8_t)c>='a' && (uint8_t)c<='z') {
      return ((uint32_t)(uint8_t)c+26UL)-97UL;
   }
   return 255UL;
} /* end d64() */


static int32_t d64(const char d[], uint32_t d_len, char b[],
                uint32_t b_len)
{
   uint32_t w;
   uint32_t c;
   uint32_t wh;
   uint32_t p;
   uint32_t wp;
   uint32_t a;
   a = 0UL;
   wp = 0UL;
   p = 0UL;
   while (p<=d_len-1 && (uint8_t)d[p]>0) {
      c = d640(d[p]);
      if (c==255UL) return -1L;
      if (c<64UL) {
         w = w*64UL+c;
         ++a;
      }
      if (c==64UL || a>=4UL) {
         if (a==2UL) w = w/16UL;
         else if (a==3UL) w = w/4UL;
         if (a>=2UL) {
            --a;
            wp += a;
            if (wp-1UL>b_len-1) return -2L;
            wh = wp-1UL;
            do {
               b[wh] = (char)(uint8_t)(char)(w&255UL);
               w = w/256UL;
               --wh;
               --a;
            } while (a);
         }
      }
      ++p;
   }
   return (int32_t)wp;
} /* end d64() */


static char getframe(float * mhz0, float * db,
                int32_t * offset, signed char dat[], uint32_t dat_len,
                uint32_t * len)
/* this is better than nothing json reader... */
{
   char ch;
   char key[100];
   char h[1001];
   int32_t ret;
   do {
   } while (getch()!='{');
   for (;;) {
      if (!getstr(key, 100ul, &ch) || ch!=':') break;
      if (aprsstr_StrCmp(key, 100ul, "rxmhz", 6ul)) {
         if (!getfix(mhz0, &ch)) break;
      }
      else if (aprsstr_StrCmp(key, 100ul, "rfdb", 5ul)) {
         if (!getfix(db, &ch)) break;
      }
      else if (aprsstr_StrCmp(key, 100ul, "offset", 7ul)) {
         if (!getint(offset, &ch)) break;
      }
      else if (aprsstr_StrCmp(key, 100ul, "payload", 8ul)) {
         if (!getstr(h, 1001ul, &ch)) break;
      }
      else if (!skip(&ch)) break;
      if ((uint8_t)ch<' ') break;
      if (ch=='}') {
         ret = d64(h, 1001ul, (char *)dat, (dat_len)/1u);
         *len = (uint32_t)ret;
         return ret>0L;
      }
   }
   return 0;
} /* end getframe() */

static uint32_t tetradec_TRAINn = 0xB970BUL;

static uint32_t tetradec_TRAINp = 0x1EC25EUL;

static uint32_t tetradec_TRAINy = 0x83973983UL;

static uint32_t tetradec_TRAINy1 = 0x39UL;

static uint32_t tetradec_TRAINx = 0x30B970B9UL;

#define tetradec_NOTFOUND 100


static uint32_t frametyp(const signed char f[], uint32_t f_len,
                uint32_t len)
{
   uint32_t j;
   uint32_t m;
   uint32_t i0;
   uint32_t e[4];
   e[0U] = 0UL;
   e[1U] = 0UL;
   e[2U] = 0UL;
   e[3U] = 0UL;
   if (len==510UL) {
      for (i0 = 0UL; i0<=21UL; i0++) {
         if (X2C_IN(i0,32,0xB970BUL)!=(int32_t)f[i0+244UL]<0L) ++e[0U];
         if (X2C_IN(i0,32,0x1EC25EUL)!=(int32_t)f[i0+244UL]<0L) ++e[1U];
      } /* end for */
      for (i0 = 0UL; i0<=31UL; i0++) {
         if (X2C_IN(i0,32,0x83973983UL)!=(int32_t)f[i0+214UL]<0L) ++e[2U];
      } /* end for */
      for (i0 = 0UL; i0<=5UL; i0++) {
         if (X2C_IN(i0,32,0x39UL)!=(int32_t)f[i0+246UL]<0L) ++e[2U];
      } /* end for */
   }
   else {
      e[0U] = 100UL;
      e[1U] = 100UL;
      e[2U] = 100UL;
   }
   if (len==206UL) {
      for (i0 = 0UL; i0<=29UL; i0++) {
         if (X2C_IN(i0,32,0x30B970B9UL)!=(int32_t)f[i0+88UL]<0L) ++e[3U];
      } /* end for */
   }
   else e[3U] = 100UL;
   m = 100UL;
   j = 0UL;
   for (i0 = 0UL; i0<=3UL; i0++) {
      if (e[i0]<m) {
         m = e[i0];
         j = i0+1UL;
      }
   } /* end for */
   /*WrStr("[");WrInt(m,1); WrStr("]"); */
   return j;
} /* end frametyp() */

static uint32_t tetradec_P = 0xDB710641UL;


static void descramble(signed char buf[], uint32_t buf_len, uint32_t reg,
                uint32_t len)
{
   uint32_t j;
   uint32_t i0;
   char b;
   uint32_t x;
   uint32_t tmp;
   tmp = len-1UL;
   i0 = 0UL;
   if (i0<=tmp) for (;; i0++) {
      x = reg&0xDB710641UL;
      b = 0;
      for (j = 0UL; j<=31UL; j++) {
         if (X2C_IN(j,32,x)) b = !b;
      } /* end for */
      reg = X2C_LSH(reg,32,-1);
      if (b) {
         reg |= 0x80000000UL;
         buf[i0] = -buf[i0];
      }
      if (i0==tmp) break;
   } /* end for */
} /* end descramble() */

enum TYPS {tetradec_PUNCT23, tetradec_PUNCT13, tetradec_PUNCT292432,
                tetradec_PUNCT148432, tetradec_PUNCT112168,
                tetradec_PUNCT72162, tetradec_PUNCT3880};



static void deinterleave(uint32_t len, uint32_t step,
                const signed char in[], uint32_t in_len, signed char out[],
                uint32_t out_len)
{
   uint32_t i0;
   uint32_t tmp;
   tmp = len;
   i0 = 1UL;
   if (i0<=tmp) for (;; i0++) {
      out[i0-1UL] = in[(step*i0)%len];
      if (i0==tmp) break;
   } /* end for */
} /* end deinterleave() */

typedef uint8_t ARR18[18];

static ARR18 tetradec_PRATE23 = {0U,1U,2U,5U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U,
                0U,0U,0U,0U};

static ARR18 tetradec_PRATE13 = {0U,1U,2U,3U,5U,6U,7U,0U,0U,0U,0U,0U,0U,0U,
                0U,0U,0U,0U};
/* Voice */

static ARR18 tetradec_PRATE812 = {0U,1U,2U,4U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U,
                0U,0U,0U,0U};

static ARR18 tetradec_PRATE818 = {0U,1U,2U,3U,4U,5U,7U,8U,10U,11U,0U,0U,0U,
                0U,0U,0U,0U,0U};

static ARR18 tetradec_PRATE817 = {0U,1U,2U,3U,4U,5U,7U,8U,10U,11U,13U,14U,
                16U,17U,19U,20U,22U,23U};

static ARR18 _cnst4 = {0U,1U,2U,3U,4U,5U,7U,8U,10U,11U,13U,14U,16U,17U,19U,
                20U,22U,23U};
static ARR18 _cnst3 = {0U,1U,2U,3U,4U,5U,7U,8U,10U,11U,0U,0U,0U,0U,0U,0U,0U,
                0U};
static ARR18 _cnst2 = {0U,1U,2U,4U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U}
                ;
static ARR18 _cnst1 = {0U,1U,2U,3U,5U,6U,7U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U}
                ;
static ARR18 _cnst0 = {0U,1U,2U,5U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U,0U}
                ;

static void depuncture(uint8_t typ0, const signed char in[],
                uint32_t in_len, uint32_t len, signed char out[],
                uint32_t out_len)
/*
0 120 p[1,2,5,9,10,13,17,18,21,25,26,29,33,34,37,41,42,45,49,50,53,57,58,61,
                65,66,69,73,74,77,81,82,85,89,90,93,97,98,101,105,106,109,
                113,114,117,121,122,125,129,130,133,137,138,141,145,146,149,
                153,154,157,161,162,165,169,170,173,177,178,181,185,186,189,
                193,194,197,201,202,205,209,210,213,217,218,221,225,226,229,
                233,234,237,241,242,245,249,250,253,257,258,261,265,266,269,
                273,274,277,281,282,285,289,290,293,297,298,301,305,306,309,
                313,314,317,]p
        0,1,4,8, 9,12,16,17,20,24,25,28,32,33,36,40,41,44,48,49,52,56,57,60,
                64,65,68,72,73,76,80,81,84,88,89,92,96,97,100,104,105,108,
                112,113,116,120,121,124,128,129,132,136,137,140,144,145,148,
                152,153,156,160,161,164,168,169,172,176,177,180,184,185,188,
                192,193,196,200,201,204,208,209,212,216,217,220,224,225,228,
                232,233,236,240,241,244,248,249,252,256,257,260,264,265,268,
                272,273,276,280,281,284,288,289,292,296,297,300,304,305,308,
                312,313,316,
        0,1,4,8, 9,12,16,17,20,24,25,28,32,33,36,40,41,44,48,49,52,56,57,60,
                64,65,68,72,73,76,80,81,84,88,89,92,96,97,100,104,105,108,
                112,113,116,120,121,124,128,129,132,136,137,140,144,145,148,
                152,153,156,160,161,164,168,169,172,176,177,180,184,185,188,
                192,193,196,200,201,204,208,209,212,216,217,220,224,225,228,
                232,233,236,240,241,244,248,249,252,256,257,260,264,265,268,
                272,273,276,280,281,284,288,289,292,296,297,300,304,305,308,
                312,313,316,


0 216 p[1,2,5,9,10,13,17,18,21,25,26,29,33,34,37,41,42,45,49,50,53,57,58,61,
                65,66,69,73,74,77,81,82,85,89,90,93,97,98,101,105,106,109,
                113,114,117,121,122,125,129,130,133,137,138,141,145,146,149,
                153,154,157,161,162,165,169,170,173,177,178,181,185,186,189,
                193,194,197,201,202,205,209,210,213,217,218,221,225,226,229,
                233,234,237,241,242,245,249,250,253,257,258,261,265,266,269,
                273,274,277,281,282,285,289,290,293,297,298,301,305,306,309,
                313,314,317,321,322,325,329,330,333,337,338,341,345,346,349,
                353,354,357,361,362,365,369,370,373,377,378,381,385,386,389,
                393,394,397,401,402,405,409,410,413,417,418,421,425,426,429,
                433,434,437,441,442,445,449,450,453,457,458,461,465,466,469,
                473,474,477,481,482,485,489,490,493,497,498,501,505,506,509,
                513,514,517,521,522,525,529,530,533,537,538,541,545,546,549,
                553,554,557,561,562,565,569,570,573,]p
        0,1,4,8, 9,12,16,17,20,24,25,28,32,33,36,40,41,44,48,49,52,56,57,60,
                64,65,68,72,73,76,80,81,84,88,89,92,96,97,100,104,105,108,
                112,113,116,120,121,124,128,129,132,136,137,140,144,145,148,
                152,153,156,160,161,164,168,169,172,176,177,180,184,185,188,
                192,193,196,200,201,204,208,209,212,216,217,220,224,225,228,
                232,233,236,240,241,244,248,249,252,256,257,260,264,265,268,
                272,273,276,280,281,284,288,289,292,296,297,300,304,305,308,
                312,313,316,320,321,324,328,329,332,336,337,340,344,345,348,
                352,353,356,360,361,364,368,369,372,376,377,380,384,385,388,
                392,393,396,400,401,404,408,409,412,416,417,420,424,425,428,
                432,433,436,440,441,444,448,449,452,456,457,460,464,465,468,
                472,473,476,480,481,484,488,489,492,496,497,500,504,505,508,
                512,513,516,520,521,524,528,529,532,536,537,540,544,545,548,
                552,553,556,560,561,564,568,569,572,
*/
{
   uint32_t d;
   uint32_t p;
   uint32_t t;
   uint32_t f;
   uint32_t k;
   uint32_t j;
   uint32_t i0;
   ARR18 P0;
   uint32_t tmp;
   f = X2C_max_longcard;
   switch ((unsigned)typ0) {
   case tetradec_PUNCT23:
      memcpy(P0,_cnst0,18u);
      t = 3UL;
      p = 8UL;
      break;
   case tetradec_PUNCT13:
      memcpy(P0,_cnst1,18u);
      t = 6UL;
      p = 8UL;
      break;
   case tetradec_PUNCT292432:
      memcpy(P0,_cnst0,18u);
      t = 3UL;
      p = 8UL;
      f = 65UL;
      break;
   case tetradec_PUNCT148432:
      memcpy(P0,_cnst1,18u);
      t = 6UL;
      p = 8UL;
      f = 35UL;
      break;
   case tetradec_PUNCT112168:
      memcpy(P0,_cnst2,18u);
      t = 3UL;
      p = 6UL;
      break;
   case tetradec_PUNCT72162:
      memcpy(P0,_cnst3,18u);
      t = 9UL;
      p = 12UL;
      break;
   case tetradec_PUNCT3880:
      memcpy(P0,_cnst4,18u);
      t = 17UL;
      p = 24UL;
      break;
   default:
      X2C_TRAP(X2C_CASE_TRAP);
   } /* end switch */
   memset((char *)out,(char)0U,out_len);
   /*WrStrLn(""); */
   tmp = len-1UL;
   j = 0UL;
   if (j<=tmp) for (;; j++) {
      i0 = j+j/f;
      d = i0/t;
      k = p*d+(uint32_t)P0[(i0+1UL)-t*d];
      out[k-1UL] = in[j];
      if (j==tmp) break;
   } /* end for */
/*WrInt(k-1,1);WrStr(","); */
/*WrStrLn(""); */
} /* end depuncture() */


static void viterbidec(signed char in[], uint32_t in_len, uint32_t len,
                char out[], uint32_t out_len)
{
   int32_t ret;
   /*  FOR i:=0 TO HIGH(in) DO in[i]:=0-in[i] END; */
   ret = conv_cch_decode(in, out, (int32_t)len);
} /* end viterbidec() */

static uint32_t tetradec_POLY = 0x1021UL; /* 0x1021*/

static uint32_t tetradec_START = 0xFFFFUL;

static uint32_t tetradec_TETRACRCOK = 0x1D0FUL;


static uint32_t crc16(const char bits[], uint32_t bits_len,
                uint32_t len)
{
   uint32_t i0;
   uint32_t c;
   uint32_t tmp;
   c = 0xFFFFUL;
   tmp = len-1UL;
   i0 = 0UL;
   if (i0<=tmp) for (;; i0++) {
      if (bits[i0]) c = c^0x8000UL;
      if ((0x8000UL & c)) c = X2C_LSH(c,32,1)^0x1021UL;
      else c = X2C_LSH(c,32,1);
      if (i0==tmp) break;
   } /* end for */
   return (uint32_t)((c^0x1D0FUL)&0xFFFFUL);
} /* end crc16() */


static uint32_t bton(const char b[], uint32_t b_len,
                uint32_t from, uint32_t len)
{
   uint32_t n;
   n = 0UL;
   while (len>0UL) {
      n += n+(uint32_t)b[from];
      ++from;
      --len;
   }
   return n;
} /* end bton() */


static uint32_t btoni(const char b[], uint32_t b_len,
                uint32_t * from, uint32_t len)
{
   uint32_t r;
   r = bton(b, b_len, *from, len);
   *from += len;
   return r;
} /* end btoni() */


static void showSBBLK1(const char b[], uint32_t b_len,
                uint32_t len, struct CONTEXT * cont)
{
   uint32_t bc;
   uint32_t cn;
   uint32_t mnc;
   uint32_t mcc0;
   /*  IF verb THEN WrStr("CC="); WrCard(bton(b, 4,6),1) END; */
   cont->tn = bton(b, b_len, 10UL, 2UL);
   cont->fn = bton(b, b_len, 12UL, 5UL);
   cont->mn = bton(b, b_len, 17UL, 6UL);
   mcc0 = bton(b, b_len, 31UL, 10UL);
   mnc = bton(b, b_len, 41UL, 14UL);
   bc = bton(b, b_len, 4UL, 6UL);
   cn = mcc0*65536UL+mnc;
   /*WrInt(scanoffs,7); WrStr("=");WrInt(cont.offset,1);  */
   if (labs(scanoffs-cont->offset)<10000L) {
      if (cont->mccmnc==cn && cont->bcc==bc) ++cont->ccc;
      else cont->ccc = 0UL;
   }
   cont->mccmnc = cn;
   cont->bcc = bc;
   cont->xor = getscramb(mcc0, mnc, cont->bcc);
   if (verb) {
      osi_WrStr(" TN=", 5ul);
      osic_WrUINT32(cont->tn, 1UL);
      osi_WrStr(" FN=", 5ul);
      osic_WrUINT32(cont->fn, 2UL);
      osi_WrStr(" MN=", 5ul);
      osic_WrUINT32(cont->mn, 1UL);
      /*    WrStr(" MCC="); WrCard(mcc,1); */
      /*    WrStr(" MNC="); WrCard(mnc,1); */
      osi_WrStr(" CC=", 5ul);
      osic_WrUINT32(mcc0, 1UL);
      osi_WrStr(",", 2ul);
      osic_WrUINT32(mnc, 1UL);
      osi_WrStr(",", 2ul);
      osic_WrUINT32(cont->bcc, 1UL);
      osi_WrStr(" ", 2ul);
   }
} /* end showSBBLK1() */

static uint8_t tetradec_LEN[8] = {0U,24U,10U,24U,34U,34U,30U,34U};

static uint8_t _cnst5[8] = {0U,24U,10U,24U,34U,34U,30U,34U};

static void showSCHf(const char b[], uint32_t b_len,
                uint32_t len)
{
   uint32_t usagemarker;
   uint32_t ssi;
   uint32_t styp;
   uint32_t n;
   uint32_t type;
   uint32_t p;
   /*WrStr(" ----B["); WrInt(bton(b,0,4),1); WrStrLn("]"); */
   if (verb) {
      p = 0UL;
      type = btoni(b, b_len, &p, 2UL); /* p613 p380 */
      osi_WrStr(" MAC=", 6ul);
      osic_WrUINT32(type, 1UL);
      if (type==0UL) {
         n = btoni(b, b_len, &p, 2UL);
         n = btoni(b, b_len, &p, 2UL);
         n = btoni(b, b_len, &p, 1UL);
         n = btoni(b, b_len, &p, 6UL);
         styp = btoni(b, b_len, &p, 3UL);
         usagemarker = 0UL;
         if (styp>0UL) {
            if (styp==3UL) osi_WrStr(" ussi=", 7ul);
            else osi_WrStr(" ssi=", 6ul);
            osic_WrUINT32(styp, 1UL);
            ssi = btoni(b, b_len, &p, (uint32_t)_cnst5[styp]);
            if (styp==6UL) {
               usagemarker = ssi&63UL;
               ssi = ssi/64UL;
            }
            osi_WrStr(":", 2ul);
            osic_WrUINT32(ssi, 1UL);
            if (styp==6UL) {
               osi_WrStr(" um:", 5ul);
               osic_WrUINT32(usagemarker, 1UL);
            }
         }
      }
      osi_WrStr(" ", 2ul);
   }
} /* end showSCHf() */

static float tetradec_OFFS[4] = {0.0f,(-6.25f),6.25f,12.5f};

static int32_t tetradec_DUPLEX[128] = {-1L,1600L,10000L,10000L,10000L,
                10000L,10000L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,4500L,
                -1L,36000L,7000L,-1L,-1L,-1L,45000L,45000L,-1L,-1L,-1L,-1L,
                -1L,-1L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,-1L,
                -1L,-1L,8000L,8000L,-1L,-1L,-1L,18000L,18000L,-1L,-1L,-1L,
                -1L,-1L,-1L,-1L,-1L,-1L,18000L,5000L,-1L,30000L,30000L,-1L,
                39000L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,9500L,-1L,-1L,
                -1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,
                -1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,
                -1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L};

static float _cnst7[4] = {0.0f,(-6.25f),6.25f,12.5f};
static int32_t _cnst6[128] = {-1L,1600L,10000L,10000L,10000L,10000L,10000L,
                -1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,4500L,-1L,36000L,
                7000L,-1L,-1L,-1L,45000L,45000L,-1L,-1L,-1L,-1L,-1L,-1L,0L,
                0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,0L,-1L,-1L,-1L,
                8000L,8000L,-1L,-1L,-1L,18000L,18000L,-1L,-1L,-1L,-1L,-1L,
                -1L,-1L,-1L,-1L,18000L,5000L,-1L,30000L,30000L,-1L,39000L,
                -1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,9500L,-1L,-1L,-1L,
                -1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,
                -1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,
                -1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L,-1L};

static void showSBBLK2(const char b[], uint32_t b_len,
                uint32_t len, struct CONTEXT * cont)
{
   uint32_t adrtyp;
   uint32_t la;
   uint32_t subscrclass;
   uint32_t hyperframenr;
   uint32_t cckid;
   uint32_t norf;
   uint32_t rtimeout;
   uint32_t accparm;
   uint32_t rxlev;
   uint32_t mspwr;
   uint32_t ncsh;
   uint32_t revers;
   uint32_t duplexspacing;
   uint32_t offs;
   uint32_t ch;
   uint32_t band;
   uint32_t i0;
   uint32_t bsservicedetails;
   int32_t shift;
   /*WrStr("B[");  FOR i:=0 TO len-1 DO WrInt(ORD(b[i]),1) END; WrStrLn("]");
                 */
   /*WrStr(" ----B["); WrInt(bton(b,0,4),1); WrStrLn("]"); */
   if (bton(b, b_len, 0UL, 4UL)==8UL) {
      /* SYSINFO p623 */
      i0 = 4UL;
      ch = btoni(b, b_len, &i0, 12UL);
      band = btoni(b, b_len, &i0, 4UL);
      offs = btoni(b, b_len, &i0, 2UL);
      duplexspacing = btoni(b, b_len, &i0, 3UL);
      revers = btoni(b, b_len, &i0, 1UL);
      ncsh = btoni(b, b_len, &i0, 2UL);
      mspwr = btoni(b, b_len, &i0, 3UL);
      rxlev = btoni(b, b_len, &i0, 4UL);
      accparm = btoni(b, b_len, &i0, 4UL);
      rtimeout = btoni(b, b_len, &i0, 4UL);
      norf = btoni(b, b_len, &i0, 1UL);
      if (norf>0UL) cckid = btoni(b, b_len, &i0, 16UL);
      else hyperframenr = btoni(b, b_len, &i0, 16UL);
      i0 = 82UL;
      la = btoni(b, b_len, &i0, 14UL); /* p1172 */
      if (labs(scanoffs-cont->offset)<10000L) {
         if (cont->la==la) ++cont->lac;
         else cont->lac = 0UL;
      }
      cont->la = la;
      subscrclass = btoni(b, b_len, &i0, 16UL);
      bsservicedetails = (uint32_t)btoni(b, b_len, &i0, 12UL);
      shift = _cnst6[band+duplexspacing*16UL];
      cont->dmhz = ((float)(band*100000UL+ch*25UL)+_cnst7[offs])*0.001f;
      if (verb) {
         osi_WrStr("TX=", 4ul);
         osic_WrFixed(cont->dmhz, 4L, 1UL);
         if (shift>=0L) {
            if (revers>0UL) shift = -shift;
            osi_WrStr(" RX=", 5ul);
            osic_WrFixed((((float)(band*100000UL+ch*25UL)+_cnst7[offs])
                -(float)shift)*0.001f, 4L, 1UL);
         }
         osi_WrStr(" Po=", 5ul);
         osic_WrUINT32(mspwr*5UL+10UL, 1UL);
         osi_WrStr("dBm", 4ul);
         osi_WrStr(" LA=", 5ul);
         osic_WrUINT32(cont->la, 1UL);
         if ((0x20UL & bsservicedetails)) osi_WrStr(" Voice-Sv", 10ul);
         if ((0x2UL & bsservicedetails)) osi_WrStr(" Air-encr", 10ul);
         printmcc(cont->mccmnc);
      }
   }
   else if (bton(b, b_len, 0UL, 2UL)==0UL) {
      /* MAC RESOURCE p612 */
      /*    WrStr(" ----B["); WrInt(bton(b,13,3),1); WrStrLn("]"); */
      adrtyp = bton(b, b_len, 13UL, 3UL);
      if (verb) {
         if (adrtyp==1UL) {
            osi_WrStr(" SSI=", 6ul); /* ASSI p739 p356 */
            osic_WrUINT32(bton(b, b_len, 16UL, 24UL), 1UL);
         }
         else if (adrtyp==3UL) {
            osi_WrStr(" USSI=", 7ul);
            osic_WrUINT32(bton(b, b_len, 16UL, 24UL), 1UL);
         }
         else if (adrtyp==4UL) {
            osi_WrStr(" SMI=", 6ul);
            osic_WrUINT32(bton(b, b_len, 16UL, 24UL), 1UL);
         }
         else if (adrtyp==6UL) {
            osi_WrStr(" USSI/UM=", 10ul);
            osic_WrUINT32(bton(b, b_len, 16UL, 30UL)/64UL, 1UL);
            osi_WrStr(":", 2ul);
            osic_WrUINT32(bton(b, b_len, 16UL, 30UL)&63UL, 1UL);
         }
         else {
            osi_WrStr("ADRTYP:", 8ul);
            osic_WrUINT32(adrtyp, 1UL);
            osi_WrStr(":", 2ul);
            osic_WrUINT32(bton(b, b_len, 16UL, 24UL), 1UL);
         }
      }
   }
   else if (bton(b, b_len, 0UL, 4UL)==9UL) {
      /* 9 MAC RESOURCE p631 */
      if (verb) {
         if (bton(b, b_len, 27UL, 2UL)==2UL) {
            /* 2 */
            osi_WrStr(" GSSI=", 7ul);
            /*WrCard(bton(b,27,2),1); WrStr(":"); */
            /*WrCard(bton(b,0,4),1); WrStr(":"); */
            osic_WrUINT32(bton(b, b_len, 45UL, 24UL), 1UL);
         }
      }
   }
} /* end showSBBLK2() */


static void SCHf(const char b[], uint32_t b_len,
                const signed char type4[], uint32_t type4_len, uint32_t len,
                 uint32_t slot)
{
   /*WrStr("S[");  FOR i:=0 TO len-1 DO WrInt(ORD(b[i]),1) END; WrStrLn("]");
                 */
   if (slot>3UL) slot = 3UL;
   if (chanfds[0U]>=0L || soundfd>=0L) {
      /* else save cpu */
      decodeaudio(type4, type4_len, slot);
   }
} /* end SCHf() */

static uint8_t tetradec_B[256] = {0U,1U,1U,2U,1U,2U,2U,3U,1U,2U,2U,3U,2U,
                3U,3U,4U,1U,2U,2U,3U,2U,3U,3U,4U,2U,3U,3U,4U,3U,4U,4U,5U,1U,
                2U,2U,3U,2U,3U,3U,4U,2U,3U,3U,4U,3U,4U,4U,5U,2U,3U,3U,4U,3U,
                4U,4U,5U,3U,4U,4U,5U,4U,5U,5U,6U,1U,2U,2U,3U,2U,3U,3U,4U,2U,
                3U,3U,4U,3U,4U,4U,5U,2U,3U,3U,4U,3U,4U,4U,5U,3U,4U,4U,5U,4U,
                5U,5U,6U,2U,3U,3U,4U,3U,4U,4U,5U,3U,4U,4U,5U,4U,5U,5U,6U,3U,
                4U,4U,5U,4U,5U,5U,6U,4U,5U,5U,6U,5U,6U,6U,7U,1U,2U,2U,3U,2U,
                3U,3U,4U,2U,3U,3U,4U,3U,4U,4U,5U,2U,3U,3U,4U,3U,4U,4U,5U,3U,
                4U,4U,5U,4U,5U,5U,6U,2U,3U,3U,4U,3U,4U,4U,5U,3U,4U,4U,5U,4U,
                5U,5U,6U,3U,4U,4U,5U,4U,5U,5U,6U,4U,5U,5U,6U,5U,6U,6U,7U,2U,
                3U,3U,4U,3U,4U,4U,5U,3U,4U,4U,5U,4U,5U,5U,6U,3U,4U,4U,5U,4U,
                5U,5U,6U,4U,5U,5U,6U,5U,6U,6U,7U,3U,4U,4U,5U,4U,5U,5U,6U,4U,
                5U,5U,6U,5U,6U,6U,7U,4U,5U,5U,6U,5U,6U,6U,7U,5U,6U,6U,7U,6U,
                7U,7U,8U}; /* number of ones in a byte */

static uint32_t tetradec_M8 = 0xFFUL;

static uint8_t _cnst8[256] = {0U,1U,1U,2U,1U,2U,2U,3U,1U,2U,2U,3U,2U,3U,3U,
                4U,1U,2U,2U,3U,2U,3U,3U,4U,2U,3U,3U,4U,3U,4U,4U,5U,1U,2U,2U,
                3U,2U,3U,3U,4U,2U,3U,3U,4U,3U,4U,4U,5U,2U,3U,3U,4U,3U,4U,4U,
                5U,3U,4U,4U,5U,4U,5U,5U,6U,1U,2U,2U,3U,2U,3U,3U,4U,2U,3U,3U,
                4U,3U,4U,4U,5U,2U,3U,3U,4U,3U,4U,4U,5U,3U,4U,4U,5U,4U,5U,5U,
                6U,2U,3U,3U,4U,3U,4U,4U,5U,3U,4U,4U,5U,4U,5U,5U,6U,3U,4U,4U,
                5U,4U,5U,5U,6U,4U,5U,5U,6U,5U,6U,6U,7U,1U,2U,2U,3U,2U,3U,3U,
                4U,2U,3U,3U,4U,3U,4U,4U,5U,2U,3U,3U,4U,3U,4U,4U,5U,3U,4U,4U,
                5U,4U,5U,5U,6U,2U,3U,3U,4U,3U,4U,4U,5U,3U,4U,4U,5U,4U,5U,5U,
                6U,3U,4U,4U,5U,4U,5U,5U,6U,4U,5U,5U,6U,5U,6U,6U,7U,2U,3U,3U,
                4U,3U,4U,4U,5U,3U,4U,4U,5U,4U,5U,5U,6U,3U,4U,4U,5U,4U,5U,5U,
                6U,4U,5U,5U,6U,5U,6U,6U,7U,3U,4U,4U,5U,4U,5U,5U,6U,4U,5U,5U,
                6U,5U,6U,6U,7U,4U,5U,5U,6U,5U,6U,6U,7U,5U,6U,6U,7U,6U,7U,7U,
                8U};

static uint32_t decodeRM(const signed char inb0[], uint32_t inb_len,
                char outb[], uint32_t outb_len)
{
   uint32_t errs;
   uint32_t best;
   uint32_t min0;
   uint32_t i0;
   uint32_t out;
   uint32_t in;
   in = 0UL;
   i0 = 0UL;
   do {
      if ((int32_t)inb0[i0]<=0L) in |= (1UL<<i0);
      ++i0;
   } while (i0<30UL);
   /*in:=in/SET32{2,12,17};  (* apply error *) */
   out = in&0x3FFFUL;
   /*WrStr("B[");  FOR i:=0 TO 29 DO WrCard(ORD(i IN in),1) END;
                WrStrLn("]"); */
   /*WrStr("O[");  FOR i:=0 TO 31 DO WrCard(ORD(i IN out),1) END;
                WrStrLn("]"); */
   if (RMTAB[(uint32_t)out]!=in) {
      /* save cpu if no error else try to correct */
      best = 0UL;
      min0 = X2C_max_longcard;
      i0 = 0UL;
      do {
         /* find best fitting RM code by stupid search */
         out = RMTAB[i0]^in;
         errs = (uint32_t)_cnst8[(uint32_t)(out&0xFFUL)]+(uint32_t)
                _cnst8[(uint32_t)(X2C_LSH(out,32,
                -8)&0xFFUL)]+(uint32_t)_cnst8[(uint32_t)(X2C_LSH(out,32,
                -16)&0xFFUL)]+(uint32_t)_cnst8[(uint32_t)X2C_LSH(out,32,
                -24)];
         /* fast error bits counter */
         if (errs<min0) {
            min0 = errs;
            best = i0;
         }
         ++i0;
      } while (i0<=16383UL);
      out = (uint32_t)best;
   }
   else min0 = 0UL;
   for (i0 = 0UL; i0<=13UL; i0++) {
      outb[13UL-i0] = X2C_IN(i0,32,out);
   } /* end for */
   if (verb && min0>0UL) {
      osi_WrStr("RM-corr=", 9ul);
      osic_WrUINT32(min0, 1UL);
      osi_WrStr(" ", 2ul);
   }
   /*WrStr("D[");  FOR i:=0 TO 13 DO WrCard(ORD(outb[i]),1) END;
                WrStrLn("]"); */
   return (uint32_t)(min0>3UL);
} /* end decodeRM() */


static void showBB(const char b[], uint32_t b_len,
                struct CONTEXT * cont)
/* p. 634 */
{
   uint32_t f2;
   uint32_t f1;
   uint32_t head;
   head = bton(b, b_len, 0UL, 2UL);
   f1 = bton(b, b_len, 2UL, 6UL);
   f2 = bton(b, b_len, 8UL, 6UL);
   cont->istrafic = 0;
   /*WrInt(cont.fn,1);WrStr("B[");
                FOR i:=0 TO 13 DO WrCard(ORD(b[i]),1) END; WrStrLn("]"); */
   /*  IF cont.fn=18 THEN */
   /*  ELSE */
   if ((head&1)) {
      /* downlink usage */
      /*WrStr("DL-Usage=");WrCard(f1, 1); WrStr(" "); */
      cont->istrafic = f1>=4UL;
   }
/*      cont.istrafic:=TRUE; */
/*    END;  */
} /* end showBB() */


static void decode(signed char fr0[], uint32_t fr_len, uint32_t start,
                uint32_t len, struct CONTEXT * cont, uint32_t ftyp)
{
   uint32_t deint;
   uint32_t crclen;
   uint32_t vitlen;
   uint32_t i0;
   signed char bd[510];
   signed char b[510];
   signed char bdp[2001];
   char bdv[2001];
   uint32_t crcok;
   uint32_t tmp;
   X2C_PCOPY((void **)&fr0,fr_len);
   tmp = len-1UL;
   i0 = 0UL;
   if (i0<=tmp) for (;; i0++) {
      b[i0] = fr0[i0+start];
      if (i0==tmp) break;
   } /* end for */
   /*WrStr("U[");  FOR i:=start TO start+len-1 DO WrInt(ORD(fr[i]<0),1); END;
                 WrStrLn("]"); */
   if (len==120UL) {
      vitlen = 80UL;
      crclen = 60UL;
      deint = 11UL;
   }
   else if (len==216UL) {
      vitlen = 144UL;
      crclen = 124UL;
      deint = 101UL;
   }
   else if (len==30UL) {
      vitlen = 0UL;
      crclen = 0UL;
   }
   else if (len==432UL) {
      vitlen = 288UL;
      crclen = 268UL;
      deint = 103UL;
   }
   /*WrStr(" len=");WrCard(len,1); */
   /*WrStr(" xor="); WrCard(CAST(CARDINAL, xor),1); WrStrLn(""); */
   descramble(b, 510ul, cont->xor, len);
   if (len==30UL) {
      /* reed muller */
      crcok = decodeRM(b, 510ul, bdv, 2001ul);
      showBB(bdv, 2001ul, cont);
   }
   else {
      deinterleave(len, deint, b, 510ul, bd, 510ul);
      depuncture(tetradec_PUNCT23, bd, 510ul, len, bdp, 2001ul);
      /*WrStr("d[");  FOR i:=0 TO len DO WrInt(bd[i],1); WrStr(" "); END;
                WrStrLn("]"); */
      viterbidec(bdp, 2001ul, vitlen, (char *)bdv, 2001u/1u);
      /*WrInt(vitlen,1);WrStr(" v[");
                FOR i:=0 TO vitlen-1 DO WrInt(ORD(bdv[i]),1); END;
                WrStrLn("]"); */
      crcok = crc16(bdv, 2001ul, crclen+16UL);
      if (verb) {
         osi_WrStr("crc=", 5ul);
         osic_WrUINT32(crcok, 1UL);
         osi_WrStr(" ", 2ul);
      }
      if (crcok==0UL) {
         if (len==120UL) showSBBLK1(bdv, 2001ul, crclen, cont);
         else if (len==216UL) {
            showSBBLK2(bdv, 2001ul, crclen, cont);
            if (ftyp==2UL) showSCHf(bdv, 2001ul, crclen);
         }
         else if (len==432UL) showSCHf(bdv, 2001ul, crclen);
      }
      /*      ELSIF len=NDBBLKBITS THEN showNDB(bdv, crclen); */
      if (len==432UL && (isuplink || cont->istrafic)) {
         SCHf(bdv, 2001ul, b, 510ul, crclen, cont->tn);
         if (verb) {
            osi_WrStr(" Data[", 7ul);
            osic_WrUINT32(context.fn, 1UL);
            osi_WrStr("/", 2ul);
            osic_WrUINT32(context.tn, 1UL);
            osi_WrStr("]", 2ul);
         }
      }
   }
   X2C_PFREE(fr0);
} /* end decode() */

static signed char fr[510];

static signed char fb[510];

static uint32_t i;

static uint32_t frlen;

static uint32_t typ;

static float mhz;


X2C_STACK_LIMIT(8000000l)
extern int main(int argc, char **argv)
{
   X2C_BEGIN(&argc,argv,1,20000000l,32000000l);
   aprsstr_BEGIN();
   aprspos_BEGIN();
   osi_BEGIN();
   initsdec();
   parms();
   if (mccfilename[0]) readmccmnc();
   RMinit();
   inlen = 0L;
   rdp = 0L;
   for (;;) {
      if (getframe(&mhz, &context.db, &context.offset, fr, 510ul,
                &frlen) && frlen>0UL) {
         if (verb) {
            if (mhz!=0.0f) {
               osic_WrFixed(mhz, 4L, 1UL);
               osi_WrStr("MHz ", 5ul);
            }
            osic_WrFixed(context.db, 1L, 1UL);
            osi_WrStr("dB ", 4ul);
            osic_WrINT32((uint32_t)context.offset, 1UL);
            osi_WrStr("Hz ", 4ul);
         }
         typ = frametyp(fr, 510ul, frlen);
         if (verb) {
            osi_WrStr("FT=", 4ul);
            osic_WrUINT32(typ, 1UL);
            osi_WrStr(" ", 2ul);
         }
         /*WrStr("r[");  FOR i:=0 TO frlen-1 DO WrInt(fr[i],1); WrStr(" ");
                END; WrStrLn("]"); */
         /*WrStr("r[");  FOR i:=0 TO frlen-1 DO WrInt(ORD(fr[i]<0),1) END;
                WrStrLn("]"); */
         if (typ==3UL) {
            context.xor = 0x3UL;
            decode(fr, 510ul, 94UL, 120UL, &context, 3UL);
            decode(fr, 510ul, 252UL, 30UL, &context, 3UL);
            decode(fr, 510ul, 282UL, 216UL, &context, 3UL);
            if (verb) osi_WrStrLn("", 1ul);
         }
         else if (typ==2UL) {
            if (isuplink) {
               decode(fr, 510ul, 28UL, 216UL, &context, 2UL);
               decode(fr, 510ul, 266UL, 216UL, &context, 2UL);
            }
            else {
               /* re-combine the broadcast block */
               for (i = 0UL; i<=13UL; i++) {
                  fb[i] = fr[i+230UL];
               } /* end for */
               for (i = 0UL; i<=15UL; i++) {
                  fb[i+14UL] = fr[i+266UL];
               } /* end for */
               decode(fb, 510ul, 0UL, 30UL, &context, 2UL);
               decode(fr, 510ul, 14UL, 216UL, &context, 2UL);
               decode(fr, 510ul, 282UL, 216UL, &context, 2UL);
            }
            if (verb) osi_WrStrLn("", 1ul);
         }
         else if (typ==1UL) {
            /* SCH/F */
            if (!isuplink) ++context.tn;
            if (context.tn>3UL) {
               context.tn = 0UL;
               context.fn = context.fn%18UL+1UL;
            }
            if (isuplink) {
               /*WrStr("u[");  FOR i:=0 TO frlen-1 DO WrInt(ORD(fr[i]<0),1);
                END; WrStrLn("]"); */
               for (i = 0UL; i<=215UL; i++) {
                  fb[i] = fr[i+28UL];
               } /* end for */
               for (i = 0UL; i<=215UL; i++) {
                  fb[i+216UL] = fr[i+266UL];
               } /* end for */
               decode(fb, 510ul, 0UL, 432UL, &context, 1UL);
            }
            else {
               /* re-combine the broadcast block */
               for (i = 0UL; i<=13UL; i++) {
                  fb[i] = fr[i+230UL];
               } /* end for */
               for (i = 0UL; i<=15UL; i++) {
                  fb[i+14UL] = fr[i+266UL];
               } /* end for */
               decode(fb, 510ul, 0UL, 30UL, &context, 1UL);
               for (i = 0UL; i<=215UL; i++) {
                  fb[i] = fr[i+14UL];
               } /* end for */
               for (i = 0UL; i<=215UL; i++) {
                  fb[i+216UL] = fr[i+282UL];
               } /* end for */
               decode(fb, 510ul, 0UL, 432UL, &context, 1UL);
            }
            if (verb) osi_WrStrLn("", 1ul);
         }
         else if (verb) osi_WrStrLn("", 1ul);
         if (labs(scanoffs-context.offset)<10000L) rxany = 1;
      }
   }
   X2C_EXIT();
   return 0;
}

X2C_MAIN_DEFINITION
